# 多线程

线程，进程，程序的关系. 程序是源文件，被执行以后变为进程，进程分裂出线程。区别: 线程是进程的一个实例，一个进程可以分裂出多个线程。

### 线程的基本机制

> Java 使用线程完成并发操作，这种并发系统会共享内存和 IO 这样的资源，因此编写多线程最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，使得些资源
  不会同时被多个线程访问。

使用场景: 在涉及多个交互式元素的场景下，需要多线程协调完成不同的功能实现交互。
  
线程的状态: new -> runnable -> blocked -> dead 

线程进入阻塞状态的几种情况:
1. sleep
2. wait 挂起。
3. 任务在等待某个 输入/输出 完成
4. 任务试图在某个对象上调用其同步方法，但锁不可用


###  共享受限资源: 当多个任务同时访问一个资源，需要用锁防止多个对象同时共享一个资源

锁: 对象锁，类锁
> 锁的关键字: `syncronized & lock`

* 每个对象都有一个锁。JVM 负责跟踪对象被加锁的次数。当一个任务第一次给一个对象加锁，锁次数 +1 ，每当这个相同的任务在对象上获得锁时，锁都会递增。每当一个任务离开一个锁，计数器递减，当
计数器为 0，资源释放，别的任务此时可以抢占资源

* 类锁。每个类都有一个锁。所以使用 `syncronized` 方法可以在类的范围防止对 static 数据的并发访问。
```java
    public class Foo {
        private static final int a = 0;
        
        public synchronized static int getA() { return a; }  // 类锁
        
        /**
         * clock 锁惯用用法
         *   
        */
        public void getOne() {
            Lock lock = new ReentrantLock();
            lock.lock();
            try{
                // doWork
            } finally{
                lock.unlock();
            }
        }
    }
```

> 同步规则，什么时候使用锁. 若一个变量，它可能将被另一个线程读取，或正在读取一个已经被另一个线程写过的变量，那么必须使用同步，且读写线程都必须用相同的监视器锁同步

原子性与易变性.原子操作是不能被线程调度机制中断的操作；一旦开始操作，那么它一定可以在可能发生上下文切换之前执行完毕

> Goetz 测试: 若你可以编写用于现代微处理器的高性能 JVM，那么就有资格去考虑是否可以避免同步

### 线程之间的协作

wait() 线程被挂起，释放对象上的锁，同时这个对象上的其他 `syncronized` 能够获取锁。

notifyAll() 唤醒 wait() 恢复执行

当调用 sleep, 或 yield 并不会释放放对象锁 

* 免锁容器. 对容器的修改可以与读取操作同时发生，只要读取者读取者能够看到修改完成的结果

